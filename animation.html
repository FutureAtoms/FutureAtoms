<!DOCTYPE html>
<html>
<head>
<title>Endless Intense Cosmic Shapes (Desktop & Mobile)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { margin: 0; overflow: hidden; background-color: #000; cursor: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; }
  canvas { display: block; touch-action: none; }
  #cursorGlow {
      position: fixed;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0) 60%);
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 1000;
      transition: background 0.1s ease;
      display: block;
  }
  body.touch-active #cursorGlow {
      display: none;
  }
</style>
</head>
<body>
<canvas id="particleCanvas"></canvas>
<div id="cursorGlow"></div>

<script>
  const canvas = document.getElementById('particleCanvas');
  const ctx = canvas.getContext('2d');
  const cursorGlow = document.getElementById('cursorGlow');
  let width, height;
  let particles = [];
  let attractors = [];
  let tempRepulsors = [];
  let hue = 0;

  // --- Tuned Parameters ---
  const explosionForce = 9;
  const particleCount = 7000;
  const attractorCount = 5;
  const drag = 0.965;
  const attractorBaseStrength = 0.12;
  const noiseStrength = 0.1;

  // --- Interaction Variables ---
  let mouseX = window.innerWidth / 2;
  let mouseY = window.innerHeight / 2;
  let mouseAttractionStrength = 1.8;
  let mouseAttractionRangeSq = 90000;
  let clickRepulsionStrength = -280;
  let clickRepulsionRadius = 280;
  let clickRepulsionDuration = 25;

  // --- Touch Specific Variables ---
  let lastTapTime = 0;
  let lastTapX = 0;
  let lastTapY = 0;
  const doubleTapThreshold = 300;
  const doubleTapMaxDistance = 30;

  // --- Endless Loop Control ---
  const recycleBoundary = 1.6;
  const attractorRecycleRadiusFactor = 0.8;
  const recycleRate = 0.1;

  class Particle {
    constructor(x, y, initialState = 'active') {
      this.state = initialState;
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.size = Math.random() * 2.5 + 0.8;
      this.baseHue = 0;
      this.distInfluence = 0;

      const shapeType = Math.random();
      if (shapeType < 0.4) this.shape = 'circle';
      else if (shapeType < 0.75) this.shape = 'square';
      else this.shape = 'triangle';
      this.rotation = 0;

      if (this.state === 'active') {
          this.spawn();
      }
    }

    spawn() {
        this.x = width / 2;
        this.y = height / 2;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * explosionForce + 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.baseHue = hue + Math.random() * 120 - 60;
        this.state = 'active';
        this.rotation = Math.atan2(this.vy, this.vx);
    }

    update() {
      if (this.state !== 'active') return;

      this.vx *= drag;
      this.vy *= drag;

      const mdx = mouseX - this.x;
      const mdy = mouseY - this.y;
      const mDistSq = mdx * mdx + mdy * mdy;
      if (mDistSq > 1 && mDistSq < mouseAttractionRangeSq) {
          const mDist = Math.sqrt(mDistSq);
          const mForce = mouseAttractionStrength * (1 + 10 / mDist);
          this.vx += mdx / mDist * mForce;
          this.vy += mdy / mDist * mForce;
      }

      tempRepulsors.forEach(repulsor => {
         const rdx = repulsor.x - this.x;
         const rdy = repulsor.y - this.y;
         const rDistSq = rdx * rdx + rdy * rdy;
         if (rDistSq > 1 && rDistSq < repulsor.radiusSq) {
             const rDist = Math.sqrt(rDistSq);
             const rForce = repulsor.strength * (repulsor.life / clickRepulsionDuration) * (1 - rDist / repulsor.radius);
             this.vx += rdx / rDist * rForce;
             this.vy += rdy / rDist * rForce;
         }
      });

      let attractForceX = 0;
      let attractForceY = 0;
      let minDistSqToAttractor = Infinity;
      let nearestAttractor = null;

      attractors.forEach(attractor => {
        const dx = attractor.x - this.x;
        const dy = attractor.y - this.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < minDistSqToAttractor) { minDistSqToAttractor = distSq; nearestAttractor = attractor; }
        if (distSq > 1) {
          const dist = Math.sqrt(distSq);
          const force = attractorBaseStrength * attractor.mass / distSq;
          attractForceX += dx / dist * force;
          attractForceY += dy / dist * force;
        }
      });
      this.vx += attractForceX;
      this.vy += attractForceY;

      this.vx += (Math.random() - 0.5) * noiseStrength;
      this.vy += (Math.random() - 0.5) * noiseStrength;

      this.x += this.vx;
      this.y += this.vy;

      if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
        this.rotation = Math.atan2(this.vy, this.vx);
      }

      if (nearestAttractor && minDistSqToAttractor < (nearestAttractor.mass * attractorRecycleRadiusFactor)) {
          this.state = 'recycling';
      }
      else if (this.x < -width * recycleBoundary || this.x > width * (1 + recycleBoundary) ||
               this.y < -height * recycleBoundary || this.y > height * (1 + recycleBoundary))
      {
          this.state = 'recycling';
      }
    }

    draw() {
      if (this.state !== 'active') return;

      const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
      const calculatedHue = (this.baseHue + speed * 5) % 360;
      const lightness = Math.min(100, 35 + speed * 18);
      const saturation = 100;

      ctx.fillStyle = `hsl(${calculatedHue}, ${saturation}%, ${lightness}%)`;

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);

      switch (this.shape) {
        case 'circle':
          ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); break;
        case 'square':
          ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size); break;
        case 'triangle':
          const h = this.size * Math.sqrt(3) / 2;
          ctx.beginPath(); ctx.moveTo(0, -h * (2/3)); ctx.lineTo(-this.size / 2, h * (1/3)); ctx.lineTo(this.size / 2, h * (1/3)); ctx.closePath(); ctx.fill(); break;
      }
      ctx.restore();
    }
  }

  class Attractor {
      constructor(x, y, mass) {
          this.x = x; this.y = y;
          this.mass = mass || Math.random() * 900 + 350;
      }
  }

  class TempRepulsor {
      constructor(x, y) { this.x = x; this.y = y; this.strength = clickRepulsionStrength; this.radius = clickRepulsionRadius; this.radiusSq = this.radius * this.radius; this.life = clickRepulsionDuration; }
      update() { this.life--; }
      draw() { if(this.life > clickRepulsionDuration * 0.7) { const alpha = (this.life - clickRepulsionDuration * 0.7) / (clickRepulsionDuration * 0.3) * 0.8; ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * (1 - this.life / clickRepulsionDuration) * 0.5 + 10, 0, Math.PI*2); ctx.fill(); } }
  }

  function setup() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    hue = Math.random() * 360;

    attractors = [];
    for (let i = 0; i < attractorCount; i++) {
        let ax = Math.random() * width * 0.9 + width * 0.05;
        let ay = Math.random() * height * 0.9 + height * 0.05;
        if (Math.sqrt((ax - width/2)**2 + (ay - height/2)**2) > Math.min(width, height) * 0.15) {
             attractors.push(new Attractor(ax, ay));
        } else {
            i--;
        }
    }
    if (attractors.length === 0) {
        attractors.push(new Attractor(width * 0.2, height * 0.2));
    }

    particles = [];
    for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle(width / 2, height / 2, Math.random() < 0.5 ? 'active' : 'recycling'));
    }
    tempRepulsors = [];

    lastTapTime = 0;
    document.body.classList.remove('touch-active');

    if (!animationFrameId) {
        animate();
    }
  }

  let animationFrameId = null;
  let particlesToRecycle = 0;

  function animate() {
      ctx.fillStyle = `rgba(0, 0, 0, 0.25)`;
      ctx.fillRect(0, 0, width, height);

      particlesToRecycle = 0;

      particles.forEach(p => {
        p.update();
        p.draw();
        if (p.state === 'recycling') {
            particlesToRecycle++;
        }
      });

      let recycledThisFrame = 0;
      const maxRecyclePerFrame = Math.ceil(particlesToRecycle * recycleRate) + Math.ceil(particleCount / 500);

      if (particlesToRecycle > 0) {
          for (let i = 0; i < particles.length && recycledThisFrame < maxRecyclePerFrame; i++) {
              if (particles[i].state === 'recycling') {
                  particles[i].spawn();
                  recycledThisFrame++;
              }
          }
      }

      for (let i = tempRepulsors.length - 1; i >= 0; i--) {
          tempRepulsors[i].update();
          tempRepulsors[i].draw();
          if (tempRepulsors[i].life <= 0) {
              tempRepulsors.splice(i, 1);
          }
      }

      if (!document.body.classList.contains('touch-active')) {
          cursorGlow.style.display = 'block';
          cursorGlow.style.left = `${mouseX}px`;
          cursorGlow.style.top = `${mouseY}px`;
          let cursorHue = hue;
          if (tempRepulsors.length > 0) {
               cursorGlow.style.background = `radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)`;
          } else {
              cursorGlow.style.background = `radial-gradient(circle, hsla(${cursorHue % 360}, 100%, 70%, 0.6) 0%, hsla(${cursorHue % 360}, 100%, 70%, 0) 60%)`;
          }
      } else {
          cursorGlow.style.display = 'none';
      }

      hue = (hue + 0.15) % 360;
      animationFrameId = requestAnimationFrame(animate);
  }

  function handleMouseMove(event) {
    document.body.classList.remove('touch-active');
    mouseX = event.clientX;
    mouseY = event.clientY;
  }

  function handleMouseDown(event) {
    if (Date.now() - lastTapTime > 50) {
       if (event.button === 0) {
           tempRepulsors.push(new TempRepulsor(event.clientX, event.clientY));
       }
    }
  }

  function handleTouchStart(event) {
    event.preventDefault();
    document.body.classList.add('touch-active');

    if (event.touches.length > 0) {
      const touchX = event.touches[0].clientX;
      const touchY = event.touches[0].clientY;

      const currentTime = Date.now();
      const timeSinceLastTap = currentTime - lastTapTime;

      const distance = Math.sqrt((touchX - lastTapX)**2 + (touchY - lastTapY)**2);

      if (timeSinceLastTap < doubleTapThreshold && distance < doubleTapMaxDistance) {
        tempRepulsors.push(new TempRepulsor(touchX, touchY));
        lastTapTime = 0;
      } else {
        mouseX = touchX;
        mouseY = touchY;
        lastTapTime = currentTime;
        lastTapX = touchX;
        lastTapY = touchY;
      }
    }
  }

  function handleTouchMove(event) {
    event.preventDefault();
    document.body.classList.add('touch-active');

    if (event.touches.length > 0) {
      mouseX = event.touches[0].clientX;
      mouseY = event.touches[0].clientY;
      lastTapTime = 0;
    }
  }

  function handleTouchEnd(event) {
    event.preventDefault();
  }

  window.addEventListener('mousemove', handleMouseMove);
  window.addEventListener('mousedown', handleMouseDown);

  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
  canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

  window.addEventListener('resize', () => {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
      setup();
  });

  setup();

</script>
</body>
</html> 